<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#ffffff">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="manifest" href="manifest.json">
    <title>Abhishek Physics</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>

    <style>
        body { -webkit-tap-highlight-color: transparent; user-select: none; font-family: sans-serif; background-color: #f8fafc; overscroll-behavior-y: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        
        /* EXACT TOUCH STYLES FROM SCREENTOUCH.HTML */
        canvas { cursor: grab; touch-action: none; }
        canvas:active { cursor: grabbing; }

        /* UI Styles */
        .scroller::-webkit-scrollbar { width: 4px; height: 4px; }
        .scroller::-webkit-scrollbar-track { background: #0f172a; }
        .scroller::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 2px; }
        .glass-panel { background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(8px); border-bottom: 1px solid rgba(51, 65, 85, 0.5); }
        .input-field { background: rgba(30, 41, 59, 0.5); border: 1px solid rgba(71, 85, 105, 0.5); color: #fff; font-family: monospace; }
        .input-field:focus { border-color: #3b82f6; outline: none; background: rgba(30, 41, 59, 0.8); }
        .eq-input { background: #1e293b; color: #a5f3fc; font-family: 'Courier New', monospace; border: 1px solid #334155; border-radius: 4px; padding: 4px 8px; font-size: 12px; width: 100%; outline: none; }
        .eq-input:focus { border-color: #3b82f6; background: #0f172a; }
    </style>
</head>
<body>

<div id="root" class="w-full h-[100dvh] flex flex-col max-w-md mx-auto bg-white shadow-2xl relative overflow-hidden"></div>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => navigator.serviceWorker.register('sw.js').catch(err => console.log('SW Failed:', err)));
    }
</script>

<script type="text/babel">
const { useState, useEffect, useRef } = React;

// --- ICONS (Merged) ---
const Icons = {
    Menu: () => <svg width="24" height="24" fill="none" stroke="#1e293b" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>,
    Back: () => <svg width="24" height="24" fill="none" stroke="#1e293b" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>,
    Atom: () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="1"/><path d="M20.2 20.2c2.04-2.03.02-7.36-4.5-11.9-4.54-4.52-9.87-6.54-11.9-4.5-2.04 2.03-.02 7.36 4.5 11.9 4.54 4.52 9.87 6.54 11.9 4.5Z"/><path d="M15.7 15.7c4.52-4.54 6.54-9.87 4.5-11.9-2.03-2.04-7.36-.02-11.9 4.5-4.52 4.54-6.54 9.87-4.5 11.9 2.03 2.04 7.36.02 11.9-4.5Z"/></svg>,
    Book: () => <svg width="24" height="24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>,
    Lab: () => <svg width="24" height="24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24"><path d="M2 12h20"/><path d="M2 12l5-5"/><path d="M22 12l-5 5"/></svg>,
    User: () => <svg width="24" height="24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>,
    Close: () => <svg width="24" height="24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
    Play: () => <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>,
    Pause: () => <svg width="16" height="16" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>,
    Reset: () => <svg width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>,
    Full: () => <svg width="16" height="16" fill="none" stroke="currentColor" strokeWidth="2" viewBox="0 0 24 24"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
};

// --- CORE: 3D CAMERA CONTROLLER (EXACTLY FROM SCREENTOUCH.HTML) ---
const useOrbitControls = (ref, initialZoom = 30) => {
    const camera = useRef({ yaw: 0.5, pitch: 0.3, zoom: initialZoom });
    const drag = useRef({ active: false, x: 0, y: 0 });

    useEffect(() => {
        const el = ref.current;
        if(!el) return;

        const start = (e) => {
            drag.current.active = true;
            const t = e.touches ? e.touches[0] : e;
            drag.current.x = t.clientX;
            drag.current.y = t.clientY;
        };
        const move = (e) => {
            if(!drag.current.active) return;
            const t = e.touches ? e.touches[0] : e;
            const dx = t.clientX - drag.current.x;
            const dy = t.clientY - drag.current.y;
            camera.current.yaw += dx * 0.01;
            camera.current.pitch += dy * 0.01;
            // Clamp pitch
            camera.current.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camera.current.pitch));
            drag.current.x = t.clientX;
            drag.current.y = t.clientY;
        };
        const end = () => drag.current.active = false;
        
        el.addEventListener('mousedown', start); el.addEventListener('touchstart', start, {passive: false});
        window.addEventListener('mousemove', move); window.addEventListener('touchmove', move, {passive: false});
        window.addEventListener('mouseup', end); window.addEventListener('touchend', end);

        return () => {
            el.removeEventListener('mousedown', start); el.removeEventListener('touchstart', start);
            window.removeEventListener('mousemove', move); window.removeEventListener('touchmove', move);
            window.removeEventListener('mouseup', end); window.removeEventListener('touchend', end);
        };
    }, []);
    return camera;
};

// --- CORE: SIM CANVAS (EXACTLY FROM SCREENTOUCH.HTML) ---
const SimCanvas = ({ draw, initZoom=30 }) => {
    const canvasRef = useRef(null);
    const cam = useOrbitControls(canvasRef, initZoom);

    useEffect(() => {
        const cvs = canvasRef.current;
        const ctx = cvs.getContext('2d');
        let fid;

        const render = () => {
            const w = cvs.width = cvs.clientWidth;
            const h = cvs.height = cvs.clientHeight;
            const cx = w/2, cy = h/2;

            ctx.fillStyle = '#020617'; // Dark Slate
            ctx.fillRect(0,0,w,h);

            // 3D Projection Function (Exact copy)
            const project = (x,y,z) => {
                const { yaw, pitch, zoom } = cam.current;
                // Rotate Y
                let x1 = x * Math.cos(yaw) - z * Math.sin(yaw);
                let z1 = z * Math.cos(yaw) + x * Math.sin(yaw);
                // Rotate X
                let y2 = y * Math.cos(pitch) - z1 * Math.sin(pitch);
                let z2 = z1 * Math.cos(pitch) + y * Math.sin(pitch);
                // Perspective
                const scale = 500 / (500 - z2) * zoom;
                return {
                    x: cx + x1 * scale,
                    y: cy - y2 * scale, // Invert Y for typical physics coords
                    s: scale,
                    z: z2
                };
            };

            // Call specific simulation draw logic
            if(draw) draw(ctx, project, w, h);

            fid = requestAnimationFrame(render);
        };
        render();
        return () => cancelAnimationFrame(fid);
    }, [draw]);

    return <canvas ref={canvasRef} className="w-full h-full block" />;
};

// --- HELPERS (Merged) ---
const parseMath = (str) => {
    try {
        if(!str) return "0";
        let s = str.toLowerCase().replace(/\s/g,'');
        s = s.replace(/\^/g, '**'); // Power
        ['sin','cos','tan','sqrt','exp','log','abs','pi'].forEach(f => {
            s = s.replaceAll(f, `Math.${f.toUpperCase()==='PI'?'PI':f}`);
        });
        return s;
    } catch(e) { return "0"; }
};

const InputRow = ({ label, val, set }) => (
    <div className="flex items-center gap-2 bg-slate-950 border border-slate-800 rounded px-2 py-1">
        <span className="text-xs font-mono text-slate-400 shrink-0">{label}</span>
        <input className="eq-input" value={val} onChange={e=>set(e.target.value)} spellCheck="false"/>
    </div>
);

const OverlayControls = ({ playing, setPlaying, fullScreen, setFullScreen, reset }) => (
    <div className="absolute top-4 right-4 flex items-center gap-2">
        <button onClick={reset} className="p-2 bg-slate-800/80 text-white rounded-full hover:bg-slate-700 backdrop-blur"><Icons.Reset/></button>
        <button onClick={()=>setPlaying(!playing)} className="p-2 bg-blue-600/90 text-white rounded-full shadow-lg hover:bg-blue-500 backdrop-blur">
            {playing ? <Icons.Pause/> : <Icons.Play/>}
        </button>
        <button onClick={()=>setFullScreen(!fullScreen)} className="p-2 bg-slate-800/80 text-white rounded-full hover:bg-slate-700 backdrop-blur"><Icons.Full/></button>
    </div>
);


// --- 1. ODESOLVER (Replaced with OrbitLab code from Screentouch) ---
const ODESolver = () => {
    const [fullScreen, setFullScreen] = useState(false);
    const [eqs, setEqs] = useState({ x:"-5*x", y:"-5*y", z:"-5*z" }); 
    const [bodies, setBodies] = useState([{x:2, y:0, z:0, vx:0, vy:2, vz:0.5, trail:[]}]);
    const [playing, setPlaying] = useState(true);
    
    // Physics Loop (Exact copy)
    useEffect(() => {
        if(!playing) return;
        const dt = 0.02;
        let updateFunc;
        try {
            updateFunc = new Function('x','y','z','t', `return { ax: ${parseMath(eqs.x)}, ay: ${parseMath(eqs.y)}, az: ${parseMath(eqs.z)} }`);
        } catch(e) { return; }

        const id = setInterval(() => {
            setBodies(prev => prev.map(b => {
                const acc = updateFunc(b.x, b.y, b.z, 0);
                const vx = b.vx + acc.ax * dt;
                const vy = b.vy + acc.ay * dt;
                const vz = b.vz + acc.az * dt;
                const x = b.x + vx * dt;
                const y = b.y + vy * dt;
                const z = b.z + vz * dt;
                
                const trail = [...b.trail, {x,y,z}];
                if(trail.length > 100) trail.shift();
                
                return { ...b, x, y, z, vx, vy, vz, trail };
            }));
        }, 16);
        return () => clearInterval(id);
    }, [playing, eqs]);

    // Draw (Exact copy)
    const draw = (ctx, project) => {
        bodies.forEach(b => {
            if(b.trail.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                for(let i=0; i<b.trail.length; i++) {
                    const p = project(b.trail[i].x, b.trail[i].y, b.trail[i].z);
                    if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            }
            const p = project(b.x, b.y, b.z);
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(p.x, p.y, 6 * (p.s/20), 0, 7); ctx.fill();
        });
    };

    return (
        <div className={`flex flex-col h-[calc(100dvh-60px)] -m-4 relative ${fullScreen ? 'fixed inset-0 z-50 m-0 bg-slate-950' : ''}`}>
             <div className={`${fullScreen ? 'h-full' : 'h-[40vh]'} relative shrink-0`}>
                <SimCanvas draw={draw} />
                <OverlayControls playing={playing} setPlaying={setPlaying} fullScreen={fullScreen} setFullScreen={setFullScreen} reset={()=>{setBodies([{x:2,y:0,z:0,vx:0,vy:2,vz:0.5,trail:[]}])}} />
            </div>
            {!fullScreen && (
                <div className="flex-1 bg-slate-950 p-4 overflow-y-auto border-t border-slate-800 space-y-4">
                    <h3 className="text-xs font-bold text-blue-400 uppercase">Acceleration Equations</h3>
                    <div className="space-y-2">
                        <InputRow label="ax =" val={eqs.x} set={v=>setEqs({...eqs, x:v})} />
                        <InputRow label="ay =" val={eqs.y} set={v=>setEqs({...eqs, y:v})} />
                        <InputRow label="az =" val={eqs.z} set={v=>setEqs({...eqs, z:v})} />
                    </div>
                    <div className="text-[10px] text-slate-500">Try: -10*x / (x^2+y^2+z^2)^1.5 (Gravity)</div>
                </div>
            )}
        </div>
    );
};

// --- 2. EMSOLVER (Replaced with EMLab code from Screentouch) ---
const EMSolver = () => {
    const [fullScreen, setFullScreen] = useState(false);
    const [fields, setFields] = useState({ Ex: "0", Ey: "0", Ez: "0", Bx: "0", By: "0", Bz: "2" }); 
    const [body, setBody] = useState({x:0, y:0, z:0, vx:2, vy:0, vz:0.5, trail:[]});
    const [playing, setPlaying] = useState(true);
    const tRef = useRef(0);

    // Physics (Exact copy)
    useEffect(() => {
        if(!playing) return;
        const dt = 0.02;
        let calcFields;
        try {
            const code = `return { 
                Ex: ${parseMath(fields.Ex)}, Ey: ${parseMath(fields.Ey)}, Ez: ${parseMath(fields.Ez)},
                Bx: ${parseMath(fields.Bx)}, By: ${parseMath(fields.By)}, Bz: ${parseMath(fields.Bz)}
            }`;
            calcFields = new Function('x','y','z','t', code);
        } catch(e) { return; }

        const id = setInterval(() => {
            tRef.current += dt;
            setBody(b => {
                const f = calcFields(b.x, b.y, b.z, tRef.current);
                const ax = f.Ex + (b.vy * f.Bz - b.vz * f.By);
                const ay = f.Ey + (b.vz * f.Bx - b.vx * f.Bz);
                const az = f.Ez + (b.vx * f.By - b.vy * f.Bx);

                const vx = b.vx + ax * dt;
                const vy = b.vy + ay * dt;
                const vz = b.vz + az * dt;
                
                const trail = [...b.trail, {x:b.x, y:b.y, z:b.z}];
                if(trail.length > 150) trail.shift();

                return { 
                    x: b.x+vx*dt, y: b.y+vy*dt, z: b.z+vz*dt, 
                    vx, vy, vz, trail, 
                    Ex: f.Ex, Ey: f.Ey, Ez: f.Ez, Bx: f.Bx, By: f.By, Bz: f.Bz 
                };
            });
        }, 16);
        return () => clearInterval(id);
    }, [playing, fields]);

    const draw = (ctx, project) => {
        if(body.trail.length > 1) {
            ctx.beginPath(); ctx.strokeStyle = '#8b5cf6'; ctx.lineWidth = 2;
            for(let i=0; i<body.trail.length; i+=2) {
                const p = project(body.trail[i].x, body.trail[i].y, body.trail[i].z);
                if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
        }
        const p = project(body.x, body.y, body.z);
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, 7); ctx.fill();

        const drawVec = (vx, vy, vz, col, scale=1) => {
            const end = project(body.x + vx*scale, body.y + vy*scale, body.z + vz*scale);
            ctx.beginPath(); ctx.strokeStyle = col; ctx.lineWidth = 2;
            ctx.moveTo(p.x, p.y); ctx.lineTo(end.x, end.y); ctx.stroke();
            ctx.fillStyle = col; ctx.beginPath(); ctx.arc(end.x, end.y, 3, 0, 7); ctx.fill();
        };
        if(body.Ex!=null) {
            drawVec(body.Ex, body.Ey, body.Ez, '#fbbf24', 1); // E
            drawVec(body.Bx, body.By, body.Bz, '#22d3ee', 1); // B
        }
    };

    return (
        <div className={`flex flex-col h-[calc(100dvh-60px)] -m-4 relative ${fullScreen ? 'fixed inset-0 z-50 m-0 bg-slate-950' : ''}`}>
             <div className={`${fullScreen ? 'h-full' : 'h-[45vh]'} relative shrink-0`}>
                <SimCanvas draw={draw} initZoom={25} />
                <OverlayControls playing={playing} setPlaying={setPlaying} fullScreen={fullScreen} setFullScreen={setFullScreen} reset={()=>{setBody({x:0,y:0,z:0,vx:2,vy:0,vz:0.5,trail:[]}); tRef.current=0;}} />
                <div className="absolute bottom-4 left-4 text-[10px] font-mono bg-black/60 p-2 rounded text-white backdrop-blur">
                    <span className="text-yellow-400">Electric (E)</span> | <span className="text-cyan-400">Magnetic (B)</span>
                </div>
            </div>
            {!fullScreen && (
                <div className="flex-1 bg-slate-900 p-4 overflow-y-auto border-t border-slate-800">
                    {/* ADDED EQUATION CARD AS REQUESTED */}
                    <div className="bg-slate-800/50 p-4 rounded-xl border border-slate-700 mb-4">
                        <div className="text-[10px] font-bold text-slate-500 uppercase mb-2">MAXWELL-LORENTZ DYNAMICS</div>
                        <div className="font-mono text-white text-sm">d²r/dt² = (q/m)(E + v × B)</div>
                    </div>

                    <div className="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <h4 className="text-[10px] font-bold text-yellow-500 mb-2 uppercase">Electric Field</h4>
                            <div className="space-y-2">
                                <InputRow label="Ex" val={fields.Ex} set={v=>setFields({...fields, Ex:v})} />
                                <InputRow label="Ey" val={fields.Ey} set={v=>setFields({...fields, Ey:v})} />
                                <InputRow label="Ez" val={fields.Ez} set={v=>setFields({...fields, Ez:v})} />
                            </div>
                        </div>
                        <div>
                            <h4 className="text-[10px] font-bold text-cyan-500 mb-2 uppercase">Magnetic Field</h4>
                            <div className="space-y-2">
                                <InputRow label="Bx" val={fields.Bx} set={v=>setFields({...fields, Bx:v})} />
                                <InputRow label="By" val={fields.By} set={v=>setFields({...fields, By:v})} />
                                <InputRow label="Bz" val={fields.Bz} set={v=>setFields({...fields, Bz:v})} />
                            </div>
                        </div>
                    </div>
                    <div className="text-[10px] text-slate-500">
                        Presets: <button className="text-blue-400 hover:underline" onClick={()=>setFields({Ex:"0",Ey:"0",Ez:"0",Bx:"0",By:"0",Bz:"2"})}>Cyclotron</button>, 
                        <button className="text-blue-400 hover:underline ml-2" onClick={()=>setFields({Ex:"0",Ey:"1",Ez:"0",Bx:"0",By:"0",Bz:"1"})}>Drift</button>,
                        <button className="text-blue-400 hover:underline ml-2" onClick={()=>setFields({Ex:"cos(t-z)",Ey:"0",Ez:"0",Bx:"0",By:"cos(t-z)",Bz:"0"})}>EM Wave</button>
                    </div>
                </div>
            )}
        </div>
    );
};

// --- 3. THERMOSOLVER (Replaced with ThermoLab code from Screentouch - FULL 3D) ---
const ThermoSolver = () => {
    const [fullScreen, setFullScreen] = useState(false);
    const [forceEq, setForceEq] = useState("0"); 
    const [volume, setVolume] = useState(1.0);
    const [particles, setParticles] = useState([]);
    const [stats, setStats] = useState({P:0, T:0});
    const [playing, setPlaying] = useState(true);

    // Init (Exact copy 3D)
    useEffect(() => {
        const arr = [];
        for(let i=0; i<80; i++) {
            arr.push({
                x: Math.random()*30, y: Math.random()*30, z: Math.random()*30,
                vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, vz: (Math.random()-0.5)*4,
                color: i<40 ? '#ef4444' : '#3b82f6'
            });
        }
        setParticles(arr);
    }, []);

    // Physics (Exact copy 3D)
    useEffect(() => {
        if(!playing) return;
        let forceFunc;
        try { forceFunc = new Function('r', `return ${parseMath(forceEq)}`); } catch(e) { return; }

        const id = setInterval(() => {
            const dt = 0.1;
            const boxW = 50 * volume; const boxH = 50; const boxD = 50;
            let impulse = 0;
            let ke = 0;

            setParticles(prev => {
                const next = prev.map(p => ({...p}));
                if(forceEq !== "0") {
                    for(let i=0; i<next.length; i++){
                        for(let j=i+1; j<next.length; j++){
                            const dx = next[j].x - next[i].x;
                            const dy = next[j].y - next[i].y;
                            const dz = next[j].z - next[i].z;
                            const r2 = dx*dx + dy*dy + dz*dz;
                            if(r2 < 64 && r2 > 0.1) {
                                const r = Math.sqrt(r2);
                                const f = forceFunc(r);
                                const fx = f * dx/r; const fy = f * dy/r; const fz = f * dz/r;
                                next[i].vx -= fx*dt; next[i].vy -= fy*dt; next[i].vz -= fz*dt;
                                next[j].vx += fx*dt; next[j].vy += fy*dt; next[j].vz += fz*dt;
                            }
                        }
                    }
                }
                next.forEach(p => {
                    p.x += p.vx * dt; p.y += p.vy * dt; p.z += p.vz * dt;
                    if(p.x < -boxW/2) { p.x = -boxW/2; p.vx *= -1; impulse += Math.abs(p.vx); }
                    if(p.x > boxW/2) { p.x = boxW/2; p.vx *= -1; impulse += Math.abs(p.vx); }
                    if(p.y < -boxH/2) { p.y = -boxH/2; p.vy *= -1; impulse += Math.abs(p.vy); }
                    if(p.y > boxH/2) { p.y = boxH/2; p.vy *= -1; impulse += Math.abs(p.vy); }
                    if(p.z < -boxD/2) { p.z = -boxD/2; p.vz *= -1; impulse += Math.abs(p.vz); }
                    if(p.z > boxD/2) { p.z = boxD/2; p.vz *= -1; impulse += Math.abs(p.vz); }
                    ke += (p.vx**2 + p.vy**2 + p.vz**2);
                });
                if(Math.random() > 0.8) {
                    setStats({
                        P: impulse / (dt * 100),
                        T: ke / next.length
                    });
                }
                return next;
            });
        }, 20);
        return () => clearInterval(id);
    }, [playing, forceEq, volume]);

    const draw = (ctx, project) => {
        const w = 50*volume; const h = 50; const d = 50;
        const corners = [
            [-w/2,-h/2,-d/2], [w/2,-h/2,-d/2], [w/2,h/2,-d/2], [-w/2,h/2,-d/2],
            [-w/2,-h/2,d/2], [w/2,-h/2,d/2], [w/2,h/2,d/2], [-w/2,h/2,d/2]
        ].map(c => project(c[0], c[1], c[2]));

        ctx.strokeStyle = '#475569'; ctx.lineWidth = 1;
        const edges = [[0,1],[1,2],[2,3],[3,0], [4,5],[5,6],[6,7],[7,4], [0,4],[1,5],[2,6],[3,7]];
        edges.forEach(e => {
            ctx.beginPath(); ctx.moveTo(corners[e[0]].x, corners[e[0]].y); ctx.lineTo(corners[e[1]].x, corners[e[1]].y); ctx.stroke();
        });
        particles.forEach(p => {
            const proj = project(p.x, p.y, p.z);
            ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(proj.x, proj.y, Math.max(2, 5*(proj.s/20)), 0, 7); ctx.fill();
        });
    };

    return (
        <div className={`flex flex-col h-[calc(100dvh-60px)] -m-4 relative ${fullScreen ? 'fixed inset-0 z-50 m-0 bg-slate-950' : ''}`}>
             <div className={`${fullScreen ? 'h-full' : 'h-[50vh]'} relative shrink-0`}>
                <SimCanvas draw={draw} initZoom={15} />
                <OverlayControls playing={playing} setPlaying={setPlaying} fullScreen={fullScreen} setFullScreen={setFullScreen} reset={()=>{}} />
                <div className="absolute bottom-4 left-4 text-[10px] font-mono text-slate-400 flex gap-4 bg-black/50 p-2 rounded backdrop-blur">
                    <span>Pres: {stats.P.toFixed(2)}</span>
                    <span>Temp: {stats.T.toFixed(2)}</span>
                    <span>Vol: {(volume*100).toFixed(0)}%</span>
                </div>
            </div>
            {!fullScreen && (
                <div className="flex-1 bg-slate-900 p-4 overflow-y-auto border-t border-slate-800 space-y-4">
                    <h3 className="text-xs font-bold text-orange-400 uppercase">Interaction Force F(r)</h3>
                    <InputRow label="F =" val={forceEq} set={setForceEq} />
                    <div className="text-[10px] text-slate-500">Positive = Repulsion. Try: 100/r^2 (Coulomb) or 12*((1/r)^13-(1/r)^7) (Lennard-Jones)</div>
                    
                    <div className="bg-slate-800 p-3 rounded">
                        <div className="flex justify-between text-xs text-slate-400 mb-2"><span>Container Volume</span><span>{volume}x</span></div>
                        <input type="range" min="0.5" max="2.0" step="0.1" value={volume} onChange={e=>setVolume(parseFloat(e.target.value))} className="w-full h-1 bg-slate-600 rounded appearance-none accent-blue-500"/>
                    </div>
                </div>
            )}
        </div>
    );
};

// --- APP ---
const App = () => {
    const [view, setView] = useState('home'); const [sim, setSim] = useState(null); const [menu, setMenu] = useState(false);
    
    // Data from original file
    const BOOKS = [
        { id: 1, title: "Physics Concept Builder Vol 1", price: "₹450", link: "https://amzn.in/d/hCAUILC", desc: "For JEE Main & Advanced", color: "bg-orange-100 text-orange-800" },
        { id: 2, title: "Advanced Problems in Physics", price: "₹650", link: "https://amzn.in/d/gSdEWNs", desc: "Problem Collection", color: "bg-blue-100 text-blue-800" },
        { id: 3, title: "Digital Physics Interactive", price: "₹200", link: "https://play.google.com/store/books/details?id=dINYEQAAQBAJ", desc: "e-Book Edition", color: "bg-green-100 text-green-800" }
    ];
    const SIMS = [
        { id: 'orbit', title: 'N-Body ODE Solver', desc: 'Coupled Differential Equations', color: 'bg-indigo-50 text-indigo-600' },
        { id: 'em', title: 'Electromagnetism', desc: 'Maxwell & Lorentz Dynamics', color: 'bg-violet-50 text-violet-600' },
        { id: 'thermo', title: 'Thermodynamics', desc: 'Stat Mech & 3 Laws', color: 'bg-orange-50 text-orange-600' },
        { id: 'pendulum', title: 'Pendulum (SHM)', desc: 'Oscillations', color: 'bg-pink-50 text-pink-600' },
        { id: 'optics', title: 'Speed of Light', desc: 'Relativity', color: 'bg-cyan-50 text-cyan-600' },
    ];
    const PROFILE = { name: "Abhishek Kumar", role: "Physics Faculty (9+ yrs)", details: ["B.Tech (CSE)", "Ex-Faculty: Jaipuria School", "Ex-Faculty: S.P. College Pune", "Expert: Python, LaTeX"] };

    // --- SimCanvas Placeholder for non-3D sims ---
    const FallbackCanvas = ({ type }) => {
        const canvasRef = useRef(null);
        useEffect(() => {
            const canvas = canvasRef.current; const ctx = canvas.getContext('2d'); let t = 0; let id;
            const render = () => { t++; const w = canvas.width = canvas.parentElement.clientWidth; const h = canvas.height = 240; ctx.fillStyle = '#1e293b'; ctx.fillRect(0,0,w,h); const cx = w/2, cy = h/2;
                if(type === 'pendulum') { ctx.fillStyle = '#f8fafc'; ctx.fillRect(0,0,w,h); const ang = Math.sin(t*0.05) * Math.PI/4; const bx = cx + 120*Math.sin(ang); const by = 20 + 120*Math.cos(ang); ctx.beginPath(); ctx.moveTo(cx,20); ctx.lineTo(bx,by); ctx.strokeStyle='#475569'; ctx.stroke(); ctx.beginPath(); ctx.arc(bx, by, 12, 0, 7); ctx.fillStyle='#e11d48'; ctx.fill(); }
                if(type === 'optics') { const lx = (t*10)%w; ctx.beginPath(); ctx.arc(lx, cy, 4, 0, 7); ctx.fillStyle='#facc15'; ctx.fill(); ctx.fillStyle='#fff'; ctx.fillText('Photon c', 10, cy-20); }
                id = requestAnimationFrame(render);
            }; render(); return () => cancelAnimationFrame(id);
        }, [type]);
        return <div className="rounded-xl overflow-hidden mt-4 shadow-inner"><canvas ref={canvasRef} className="block w-full h-[240px]"/></div>;
    };

    return (
        <div className="flex flex-col h-full bg-slate-50">
            <header className="bg-white border-b border-slate-200 px-4 py-3 flex justify-between items-center shrink-0 sticky top-0 z-20">
                <div className="flex items-center gap-2" onClick={() => setView('home')}>
                    <div className="w-8 h-8 rounded-lg bg-blue-600 text-white flex items-center justify-center font-bold">P</div>
                    <span className="font-bold text-slate-800">Physics</span>
                </div>
                <button onClick={() => setMenu(true)} className="p-2"><Icons.Menu /></button>
            </header>
            <div className={`fixed inset-0 z-50 bg-black/50 transition-opacity ${menu ? 'opacity-100' : 'opacity-0 pointer-events-none'}`} onClick={() => setMenu(false)}>
                <div className={`absolute right-0 top-0 bottom-0 w-72 bg-white shadow-2xl p-6 transition-transform duration-300 ${menu ? 'translate-x-0' : 'translate-x-full'}`} onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center mb-8"><h2 className="font-bold text-xl">Profile</h2><button onClick={() => setMenu(false)}><Icons.Close /></button></div>
                    <div className="text-center mb-6"><div className="w-20 h-20 bg-blue-100 text-blue-600 rounded-full mx-auto flex items-center justify-center mb-3"><Icons.User /></div><h3 className="font-bold text-lg text-slate-800">{PROFILE.name}</h3><p className="text-sm text-slate-500">{PROFILE.role}</p></div>
                    <div className="space-y-3 text-sm text-slate-600">{PROFILE.details.map((d, i) => <div key={i} className="pl-3 border-l-2 border-blue-500">{d}</div>)}</div>
                </div>
            </div>
            <main className="flex-1 overflow-y-auto no-scrollbar p-4 pb-24">
                {view === 'home' && (
                    <div className="space-y-6">
                        <div className="bg-slate-900 text-white p-6 rounded-2xl relative overflow-hidden shadow-xl"><div className="relative z-10"><h1 className="text-2xl font-bold mb-1">Visual Labs</h1><p className="text-slate-400 text-sm">Interactive Physics for JEE</p></div><Icons.Atom className="absolute right-[-10px] bottom-[-10px] w-24 h-24 text-slate-700 opacity-50" /></div>
                        <div><h3 className="font-bold text-slate-800 mb-3 text-sm uppercase tracking-wide">Experiments</h3><div className="space-y-3">{SIMS.map(s => (<button key={s.id} onClick={() => { setSim(s.id); setView('sim'); }} className="w-full bg-white p-4 rounded-xl border border-slate-100 shadow-sm flex items-center gap-4 text-left"><div className={`w-10 h-10 rounded-lg flex items-center justify-center shrink-0 ${s.color}`}><Icons.Atom /></div><div><div className="font-bold text-slate-900">{s.title}</div><div className="text-xs text-slate-500">{s.desc}</div></div></button>))}</div></div>
                    </div>
                )}
                {view === 'sim' && (
                    <div className="animate-in slide-in-from-bottom duration-300">
                        <button onClick={() => setView('home')} className="flex items-center gap-2 text-slate-500 mb-4 font-bold text-sm"><Icons.Back /> Back</button>
                        <h2 className="text-2xl font-bold text-slate-900 mb-2">{SIMS.find(s=>s.id===sim)?.title}</h2>
                        {sim === 'orbit' ? <ODESolver /> : sim === 'em' ? <EMSolver /> : sim === 'thermo' ? <ThermoSolver /> : <FallbackCanvas type={sim} />}
                    </div>
                )}
                {view === 'books' && (<div className="space-y-4"><h2 className="font-bold text-xl text-slate-800">Study Material</h2>{BOOKS.map(b => (<div key={b.id} className="bg-white rounded-xl p-4 shadow-sm border border-slate-100 flex gap-4"><div className={`w-20 h-24 shrink-0 rounded flex items-center justify-center ${b.color}`}><Icons.Book /></div><div className="flex-1 flex flex-col"><h3 className="font-bold text-slate-900 leading-tight">{b.title}</h3><p className="text-xs text-slate-500 mt-1 mb-2">{b.desc}</p><div className="mt-auto flex justify-between items-center"><span className="text-xs font-bold bg-green-100 text-green-700 px-2 py-1 rounded">{b.price}</span><a href={b.link} target="_blank" className="text-xs font-bold bg-slate-900 text-white px-3 py-2 rounded">Buy Now</a></div></div></div>))}</div>)}
            </main>
            <nav className="fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 h-16 flex justify-around items-center z-30 max-w-md mx-auto"><button onClick={() => setView('home')} className={`flex flex-col items-center gap-1 p-2 ${view!=='books'?'text-blue-600':'text-slate-400'}`}><Icons.Lab /><span className="text-[10px] font-bold">Labs</span></button><button onClick={() => setView('books')} className={`flex flex-col items-center gap-1 p-2 ${view==='books'?'text-blue-600':'text-slate-400'}`}><Icons.Book /><span className="text-[10px] font-bold">Books</span></button></nav>
        </div>
    );
};
const root = ReactDOM.createRoot(document.getElementById('root')); root.render(<App />);
</script>
</body>
</html>
